<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>How to add a new Lidar driver &mdash; Apollo Auto alpha 文档</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/tabs.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/cyber/doxy-docs/source/main_stylesheet.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/tabs.js"></script>
        <script src="../../_static/translations.js"></script>
        <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
        <script>mermaid.initialize({startOnLoad:true});</script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="fr" href="how_to_add_a_new_lidar_driver_cn.html" />
    <link rel="prev" title="如何添加新的lidar检测算法" href="how_to_add_a_new_lidar_detector_algorithm_cn.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: skyblue" >
            <a href="../../index.html" class="icon icon-home"> Apollo Auto
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../README.html">Apollo Auto 自述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Apollo Auto 文档</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cyber/doxy-docs/source/index.html">cyber 文档</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: skyblue" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Apollo Auto</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>How to add a new Lidar driver</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/docs/howto/how_to_add_a_new_lidar_driver.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="how-to-add-a-new-lidar-driver">
<h1>How to add a new Lidar driver<a class="headerlink" href="#how-to-add-a-new-lidar-driver" title="永久链接至标题"></a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="永久链接至标题"></a></h2>
<p>Lidar is a commonly used environment-aware sensor. Lidar uses pulsed laser to illuminate a target, receives the reflected pulse from the target, then calculates the distance to the target based on the time of laser return. Differences in multiple measurements can then be used to make digital 3-D representations of the environment.</p>
<p>As default, Apollo platform support multiple types of Lidar drivers, including 16 channels, 32 channels, 64 channels and 128 channels Velodyne lidars. This manual describes the major functions of Lidar driver and how to add a new lidar driver in Apollo platform.</p>
</section>
<section id="whats-inside-a-lidar-driver">
<h2>What’s inside a lidar driver<a class="headerlink" href="#whats-inside-a-lidar-driver" title="永久链接至标题"></a></h2>
<p>Taking velodyne lidar driver as an example, there are three major components:</p>
<ol class="simple">
<li><p><span class="xref myst">Driver</span>: Driver receives UDP data packets from lidar sensor, and packages the data packets into a frame of scanning data in the format of VelodyneScan. VelodyneScan is defined in file below:</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">modules</span><span class="o">/</span><span class="n">drivers</span><span class="o">/</span><span class="n">lidar</span><span class="o">/</span><span class="n">velodyne</span><span class="o">/</span><span class="n">proto</span><span class="o">/</span><span class="n">velodyne</span><span class="o">.</span><span class="n">proto</span>
</pre></div>
</div>
<ol class="simple">
<li><p><span class="xref myst">Parser</span>: Parser takes one frame data in format of VelodyneScan as input, converts the cloud points in the frame from spherical coordinate system to Cartesian coordinates system, then sends out the point cloud as output. The pointcloud format is defined in file below:</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">modules</span><span class="o">/</span><span class="n">drivers</span><span class="o">/</span><span class="n">proto</span><span class="o">/</span><span class="n">pointcloud</span><span class="o">.</span><span class="n">proto</span>
</pre></div>
</div>
<ol class="simple">
<li><p><span class="xref myst">Compensator</span>: Compensator takes pointcloud data and pose data as inputs. Based on the corresponding pose information for each cloud point, it converts each cloud point information aligned with the latest time in the current lidar scan frame, minimizing the motion error due the movement of the vehicle. Thus, each cloud point needs carry its own timestamp information.</p></li>
</ol>
</section>
<section id="steps-to-add-a-new-lidar-driver">
<h2>Steps to add a new Lidar driver<a class="headerlink" href="#steps-to-add-a-new-lidar-driver" title="永久链接至标题"></a></h2>
<section id="get-familiar-with-apollo-cyber-rt-framework">
<h3>1. Get familiar with Apollo Cyber RT framework.<a class="headerlink" href="#get-familiar-with-apollo-cyber-rt-framework" title="永久链接至标题"></a></h3>
<p>Please refer to the <a class="reference internal" href="../cyber/README.html"><span class="doc std std-doc">manuals of Apollo Cyber RT</span></a>.</p>
</section>
<section id="define-message-for-raw-data">
<h3>2. Define message for raw data<a class="headerlink" href="#define-message-for-raw-data" title="永久链接至标题"></a></h3>
<p>Apollo already define the format of pointcloud. For new lidar, you only need to define the protobuf message for the raw scannning data. Those raw data will be used for archive and offline development. Compared to processed pointcloud data, raw data saves a lot of storage spaces for long term. The new message of the scan data can be define as below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// a scan message sample</span>
<span class="n">message</span><span class="w"> </span><span class="n">ScanData</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">	</span><span class="n">optional</span><span class="w"> </span><span class="n">apollo</span><span class="p">.</span><span class="n">common</span><span class="p">.</span><span class="n">Header</span><span class="w"> </span><span class="n">header</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">  </span><span class="c1">// apollo header</span>
<span class="w">	</span><span class="n">optional</span><span class="w"> </span><span class="n">Model</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">                  </span><span class="c1">// device model</span>
<span class="w">	</span><span class="n">optional</span><span class="w"> </span><span class="n">Mode</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">                    </span><span class="c1">// work mode</span>
<span class="w">	</span><span class="c1">// device serial number, corresponds to a specific calibration file</span>
<span class="w">	</span><span class="n">optional</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">sn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">	</span><span class="n">repeated</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="n">raw_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">               </span><span class="c1">// raw scan data</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In velodyne driver, the scan data message is define as <a class="reference external" href="../../modules/drivers/lidar/velodyne/proto/velodyne.proto#L29">VelodyneScan</a>.</p>
</section>
<section id="access-the-raw-data">
<h3>3. Access the raw data<a class="headerlink" href="#access-the-raw-data" title="永久链接至标题"></a></h3>
<p>Each seconds, Lidar will generate a lot of data, so it relied on UDP to efficiently transport the raw data. You need to create a DriverComponent class, which inherits the Component withotu any parameter. In its Init function, you need to start a async polling thread, whic will receive Lidar data from the specific port. Then depending on the Lidar’s frequency, the DriverComponent needs to package all the packets in a fix period into a frame of ScanData. Eventually, the writer will send the ScanData through a corresponding channel.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Inherit component with no template parameters,</span>
<span class="c1">// do not receive message from any channel</span>
<span class="k">class</span> <span class="nc">DriverComponent</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Component</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="o">~</span><span class="n">VelodyneDriverComponent</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">Init</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  	</span><span class="n">poll_thread_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kr">thread</span><span class="p">([</span><span class="k">this</span><span class="p">]{</span><span class="w"></span>
<span class="w">  		</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Poll</span><span class="p">();</span><span class="w"></span>
<span class="w">  	</span><span class="p">}));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">Poll</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  	</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">apollo</span><span class="o">::</span><span class="n">cyber</span><span class="o">::</span><span class="n">Ok</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  	  </span><span class="c1">// poll data from port xxx</span>
<span class="w">  	  </span><span class="c1">// ...</span>
<span class="w">  	  </span><span class="n">austo</span><span class="w"> </span><span class="n">scan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">ScanData</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">  	  </span><span class="c1">// pack ScanData</span>
<span class="w">  	  </span><span class="c1">// ...</span>
<span class="w">  	  </span><span class="n">writer_</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">scan</span><span class="p">);</span><span class="w"></span>
<span class="w">  	</span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span><span class="w"> </span><span class="n">poll_thread_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">apollo</span><span class="o">::</span><span class="n">cyber</span><span class="o">::</span><span class="n">Writer</span><span class="o">&lt;</span><span class="n">ScanData</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">writer_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">CYBER_REGISTER_COMPONENT</span><span class="p">(</span><span class="n">DriverComponent</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="parse-the-scan-data-convert-to-pointcloud">
<h3>4. Parse the scan data, convert to pointcloud<a class="headerlink" href="#parse-the-scan-data-convert-to-pointcloud" title="永久链接至标题"></a></h3>
<p>If the new lidar driver already provides the pointcloud data in Cartesian coordinates system, then you just need to store those data in the protobuf format defined in Apollo.</p>
<p>The Parser converts the lidar raw data to the pointcloud format in Cartesian coordinates system. Parser takes ScanData as input. For each cloud point, it will parse the timestamp, x/y/z coordinates and intensity, then packages all the cloudpoint information into a frame of pointcloud. Each cloud point transformed into the FLU (Front: x, Left: y, Up: z）coordinates with Lidar as the origin point.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">message</span><span class="w"> </span><span class="n">PointXYZIT</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">optional</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">[</span><span class="k">default</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nan</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">optional</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="k">default</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nan</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">optional</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">[</span><span class="k">default</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nan</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">optional</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">intensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">[</span><span class="k">default</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">optional</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">[</span><span class="k">default</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Then you need to create a new ParserComponent，which inherits Components templates with ScanData. ParserComponent takes ScanData as input, then generates pointcloud message and sents it out.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"></span>
<span class="k">class</span> <span class="nc">ParserComponent</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Component</span><span class="o">&lt;</span><span class="n">ScanData</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">Init</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  	</span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">Proc</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ScanData</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">scan_msg</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// get a pointcloud object from objects pool</span>
<span class="w">  	</span><span class="k">auto</span><span class="w"> </span><span class="n">point_cloud_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point_cloud_pool_</span><span class="o">-&gt;</span><span class="n">GetObject</span><span class="p">();</span><span class="w"></span>
<span class="w">  	</span><span class="c1">// clear befor using</span>
<span class="w">  	</span><span class="n">point_cloud_out</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span><span class="w"></span>
<span class="w">  	</span><span class="c1">// parse scan data and generate pointcloud</span>
<span class="w">  	</span><span class="n">parser_</span><span class="o">-&gt;</span><span class="n">parse</span><span class="p">(</span><span class="n">scan_msg</span><span class="p">,</span><span class="w"> </span><span class="n">point_cloud_out</span><span class="p">);</span><span class="w"></span>
<span class="w">  	</span><span class="c1">// write pointcloud to a specific channel</span>
<span class="w">  	</span><span class="n">writer_</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">point_cloud</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Writer</span><span class="o">&lt;</span><span class="n">PointCloud</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">writer_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Parser</span><span class="o">&gt;</span><span class="w"> </span><span class="n">parser_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CCObjectPool</span><span class="o">&lt;</span><span class="n">PointCloud</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">point_cloud_pool_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">pool_size_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">CYBER_REGISTER_COMPONENT</span><span class="p">(</span><span class="n">ParserComponent</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="motion-compensation-for-pointcloud">
<h3>5. Motion compensation for pointcloud<a class="headerlink" href="#motion-compensation-for-pointcloud" title="永久链接至标题"></a></h3>
<p>Motion compensation is optional depends on lidar hardware design. E.g. if the the pointcloud information from lidar already have the motion error included, then no compensator needed as extra steps. Otherwise, you need your own compensator. However, if each cloud point in your lidar’s output carries its own timestamp information, you can probably reuse the current compensator without any changes.</p>
</section>
<section id="configure-the-dag-file">
<h3>6. Configure the dag file<a class="headerlink" href="#configure-the-dag-file" title="永久链接至标题"></a></h3>
<p>After done with each component, you just need to configure the DAG config file to add each component into the data processing pipeline. E.g.  lidar_driver.dag:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define all coms in DAG streaming.</span>
<span class="n">module_config</span> <span class="p">{</span>
    <span class="n">module_library</span> <span class="p">:</span> <span class="s2">&quot;/apollo/bazel-bin/modules/drivers/lidar/xxx/driver/libxxx_driver_component.so&quot;</span>
    <span class="n">components</span> <span class="p">{</span>
      <span class="n">class_name</span> <span class="p">:</span> <span class="s2">&quot;DriverComponent&quot;</span>
      <span class="n">config</span> <span class="p">{</span>
        <span class="n">name</span> <span class="p">:</span> <span class="s2">&quot;xxx_driver&quot;</span>
        <span class="n">config_file_path</span> <span class="p">:</span> <span class="s2">&quot;/path/to/lidar_driver_conf.pb.txt&quot;</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">module_config</span> <span class="p">{</span>
    <span class="n">module_library</span> <span class="p">:</span> <span class="s2">&quot;/apollo/bazel-bin/modules/drivers/lidar/xxx/parser/libxxx_parser_component.so&quot;</span>
    <span class="n">components</span> <span class="p">{</span>
      <span class="n">class_name</span> <span class="p">:</span> <span class="s2">&quot;ParserComponent&quot;</span>
      <span class="n">config</span> <span class="p">{</span>
        <span class="n">name</span> <span class="p">:</span> <span class="s2">&quot;xxx_parser&quot;</span>
        <span class="n">config_file_path</span> <span class="p">:</span> <span class="s2">&quot;/path/to/lidar_parser_conf.pb.txt&quot;</span>
        <span class="n">readers</span> <span class="p">{</span> <span class="n">channel</span><span class="p">:</span> <span class="s2">&quot;/apollo/sensor/xxx/Scan&quot;</span> <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">module_config</span> <span class="p">{</span>
    <span class="n">module_library</span> <span class="p">:</span> <span class="s2">&quot;/apollo/bazel-bin/modules/drivers/lidar/xxx/compensator/libxxx_compensator_component.so&quot;</span>
    <span class="n">components</span> <span class="p">{</span>
      <span class="n">class_name</span> <span class="p">:</span> <span class="s2">&quot;CompensatorComponent&quot;</span>
      <span class="n">config</span> <span class="p">{</span>
        <span class="n">name</span> <span class="p">:</span> <span class="s2">&quot;pointcloud_compensator&quot;</span>
        <span class="n">config_file_path</span> <span class="p">:</span> <span class="s2">&quot;/apollo/modules/drivers/lidar/xxx/conf/xxx_compensator_conf.pb.txt&quot;</span>
        <span class="n">readers</span> <span class="p">{</span><span class="n">channel</span><span class="p">:</span> <span class="s2">&quot;/apollo/sensor/xxx/PointCloud2&quot;</span><span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="run-the-lidar-driver-and-visualize-the-pointlcoud-output">
<h3>7. Run the lidar driver and visualize the pointlcoud output<a class="headerlink" href="#run-the-lidar-driver-and-visualize-the-pointlcoud-output" title="永久链接至标题"></a></h3>
<p>After finishing all the previous steps, you can use the following command to start your new lidar driver.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mainboard -d /path/to/lidar_driver.dag
</pre></div>
</div>
<p>To visualize the pointcloud output, you can run <code class="docutils literal notranslate"><span class="pre">cyber_visualizer</span></code> and choose the right channel for the pointcloud.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="how_to_add_a_new_lidar_detector_algorithm_cn.html" class="btn btn-neutral float-left" title="如何添加新的lidar检测算法" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="how_to_add_a_new_lidar_driver_cn.html" class="btn btn-neutral float-right" title="fr" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2021, xinetzone.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>